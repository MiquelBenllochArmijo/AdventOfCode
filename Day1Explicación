Justificaci√≥n de la T√©cnica de Divide y Vencer√°s
La t√©cnica de divide y vencer√°s es particularmente adecuada para este problema porque reduce significativamente la complejidad computacional de ordenar y procesar grandes conjuntos de datos. En este caso, se utiliza para ordenar la lista left_side eficientemente mediante el algoritmo merge sort, que tiene una complejidad de 
ùëÇ
(
ùëõ
log
‚Å°
ùëõ
)
O(nlogn). Este ordenamiento es crucial porque:

Emparejamiento Eficiente: Al ordenar los elementos, se facilita la comparaci√≥n directa de los n√∫meros de ambas listas de menor a mayor.
Reducci√≥n de Costo Computacional: Permite calcular eficientemente las m√©tricas requeridas (como la similitud ponderada) al evitar operaciones innecesarias.
Ordenar las listas antes de calcular las distancias o frecuencias no solo mejora la eficiencia, sino que tambi√©n asegura que el proceso sea escalable para grandes cantidades de datos.

Descripci√≥n T√©cnica del Proceso de Resoluci√≥n
Entrada de Datos
El programa lee dos listas de enteros desde un archivo llamado "day1_puzzle".
Cada l√≠nea del archivo contiene dos n√∫meros: uno que se almacena en la lista left_side y otro en right_side.
Preparaci√≥n Inicial
Almacenamiento de Datos: Los n√∫meros le√≠dos se colocan en dos vectores separados: left_side y right_side.
Estructuras Auxiliares:
Se utiliza un mapa hash (unordered_map) para almacenar las frecuencias de los n√∫meros en la lista izquierda.
Cada clave en el mapa representa un n√∫mero, y su valor es una estructura recurrent que contiene:
number_of_times_left_side: N√∫mero de ocurrencias en left_side.
number_of_times_right_side: N√∫mero de ocurrencias en right_side.
Ordenamiento de las Listas
El algoritmo de merge sort es implementado para ordenar left_side:

Divisi√≥n Recursiva: El vector se divide en mitades hasta que cada subvector contiene un √∫nico elemento.
Fusi√≥n Ordenada: Las mitades se combinan en orden ascendente utilizando un paso de fusi√≥n eficiente.
Complejidad: El algoritmo garantiza una eficiencia de 

O(nlogn).
C√°lculo de la Similitud Ponderada
Frecuencias de N√∫meros:
Cada n√∫mero de left_side se registra en el mapa con su frecuencia.
Luego, para cada n√∫mero de right_side, si est√° presente en el mapa, se incrementa el contador correspondiente (number_of_times_right_side).
F√≥rmula de Similitud:
Para cada n√∫mero presente en ambas listas, se multiplica su frecuencia en la izquierda, su frecuencia en la derecha y su valor num√©rico.
La suma de estos productos da la similitud ponderada total.
C√°lculo de la Distancia Total (Parte 2)
Adem√°s de la similitud ponderada, se incorpora el c√°lculo de la distancia total entre las listas:

Emparejamiento Ordenado:
Tras ordenar las listas, se emparejan los elementos correspondientes por posici√≥n.
La distancia entre cada par se calcula como la diferencia absoluta: 

‚à£left[i]‚àíright[i]‚à£.
Acumulaci√≥n:
Estas distancias se suman para obtener la discrepancia total entre las listas.
